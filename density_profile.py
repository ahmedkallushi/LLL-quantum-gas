# -*- coding: utf-8 -*-
"""Density Profile

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YRPeaigNB7jTt0I7jY-N85dksLBk1rst
"""

import numpy as np
from numpy import linalg
from itertools import permutations
import matplotlib.pyplot as plt

#PARAMETERS

L=2.5
e = 2.718281828
pi = 3.141592654

n_p = 4

n_s = 5

def generate_hamiltonians(sites):

  order = []

  for n in range(sites):
    temp = [n for m in range(4)]
    order  = temp + order

  all_hamiltonians = list(set(permutations(order,4)))
  hamiltonians = []

  for n in all_hamiltonians:
    kronecker = n[0]+n[1]-n[2]-n[3]

    if kronecker == 0:
      hamiltonians.append(n)

  return hamiltonians

hamiltonian = generate_hamiltonians(n_s)

def generate_basis(sites, particles):
    if sites == 1:
        return [[particles]]
    else:
        basis = []
        for i in range(particles + 1):
            temp = generate_basis(sites - 1, particles - i)
            for vec in temp:
                basis.append([i] + vec)
        return basis

basis = generate_basis(n_s,n_p)

def raising(site,ket):

  factor = np.sqrt(ket[site]+1)

  ket[site]=ket[site]+1

  return ket, factor

def lowering(site,ket):

  if ket[site] == 0:
    ket = 0
    factor = 0
    return ket, factor

  else:
    factor = np.sqrt(ket[site])
    ket[site]=ket[site]-1

    return ket, factor


def elements(order, bra, ket):

  ket_0 = ket.copy()
  op_1 = lowering(order[3],ket_0)

  ket_1 = op_1[0]
  factor = op_1[1]

  if ket_1 == 0:
    matrix_element = 0
    return matrix_element

  else:
    op_2 = lowering(order[2],ket_1)
    ket_2=op_2[0]
    factor = factor*op_2[1]

  if ket_2 == 0:
    matrix_element = 0
    return matrix_element

  else:
    op_3 = raising(order[1],ket_2)
    ket_3 = op_3[0]
    factor = factor*op_3[1]

    op_4 = raising(order[0],ket_3)
    ket_4 = op_4[0]
    factor = factor*op_4[1]

    if ket_4 == bra:
      matrix_element = factor
      matrix_element = matrix_element*(np.exp((-(2*pi**2)/(L**2))*(((order[0]-order[2])**2)+(order[1]-order[2])**2)))
      return round(matrix_element,8)
    else:
      matrix_element = 0
      return matrix_element

matrix = 0

def matrix_representation(hamiltonian,basis):
  matrix = []
  for n in range(len(basis)):
    row = [elements(hamiltonian,basis[n],basis[m]) for m in range(len(basis))]
    matrix.append(row)
  return matrix

for n in range(len(hamiltonian)):
  temp =np.matrix(matrix_representation(hamiltonian[n],basis))
  matrix = matrix+temp

eval_noround= np.linalg.eigh(matrix)[0]

eval = [float('%.5f' % n) for n in eval_noround]
print(eval)

evect = np.linalg.eigh(matrix)[1]

def occupation(eval, evect):
  groundstate = np.matrix(evect.transpose()[0] / np.linalg.norm(evect.transpose()[0]))
  groundstate = groundstate.tolist()[0]

  occupation = []

  for n in range(n_s):
    temp = 0
    for m in range(len(basis)):
      temp = temp + ((groundstate[m]**2)*basis[m][n])
    occupation.append(temp)

  state = 1

  while eval[0]==eval[state]:

    groundstate_degen = np.matrix(evect.transpose()[state] / np.linalg.norm(evect.transpose()[state]))
    groundstate_degen = groundstate_degen.tolist()[0]
    occupation_degen = []

    for n in range(n_s):
      temp = 0
      for m in range(len(basis)):
        temp = temp + ((groundstate_degen[m]**2)*basis[m][n])
      occupation_degen.append(temp)

    occupation = [occupation[n]+occupation_degen[n] for n in range(n_s)]

    state = state + 1
  occupation = [occupation[n]/state for n in range(n_s)]
  print(state,"-fold Degenerate")
  return occupation

y = np.arange(-5,25,0.1)

particles = occupation(eval,evect)
density = []


for m in y:
  temp = 0
  for n in range(n_s):
    temp = temp+ (1/np.sqrt(pi))*particles[n]*np.exp(-((m)-(2*pi*n/L))**2)
  density.append(temp)


plt.plot(y,density)
plt.xlabel("$y/l_b$")
plt.ylabel("Density")

